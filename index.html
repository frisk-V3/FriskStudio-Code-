<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>FNF Psych Engine Chart Editor (ÂØæÊà¶Âûã)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1e1e1e;
            color: #fff;
        }

        .container {
            display: flex;
            width: 100%;
            height: 100vh;
        }

        .sidebar {
            width: 280px;
            background: #2d2d2d;
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #444;
            flex-shrink: 0;
        }

        .sidebar h1 {
            font-size: 24px;
            margin-bottom: 20px;
            color: #ff6b6b;
        }

        .sidebar h2 {
            font-size: 14px;
            margin-top: 20px;
            margin-bottom: 10px;
            color: #ffda77;
            text-transform: uppercase;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }

        .section {
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 12px;
        }

        .form-group label {
            display: block;
            font-size: 12px;
            margin-bottom: 4px;
            color: #aaa;
            text-transform: uppercase;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #444;
            background: #1e1e1e;
            color: #fff;
            border-radius: 4px;
            font-size: 14px;
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #ff6b6b;
            background: #252525;
        }

        .btn {
            width: 100%;
            padding: 10px;
            margin-bottom: 8px;
            border: none;
            background: #4a90e2;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #357abd;
        }

        .btn:active {
            background: #2a5a99;
        }

        .btn-danger {
            background: #e74c3c;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn-secondary {
            background: #7f8c8d;
        }

        .btn-secondary:hover {
            background: #5d6d7b;
        }

        .btn-small {
            width: auto;
            padding: 8px 12px;
            margin: 0 4px 0 0;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #444;
            font-size: 12px;
        }

        .stat-item strong {
            color: #ffda77;
        }

        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .tab-btn {
            flex: 1;
            padding: 8px;
            border: none;
            background: #3d3d3d;
            color: #aaa;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            transition: background 0.2s;
        }

        .tab-btn:hover {
            background: #4a4a4a;
        }

        .tab-btn.active {
            background: #4a90e2;
            color: #fff;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow: hidden;
        }

        .editor-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .editor-controls .btn {
            width: auto;
            padding: 8px 12px;
            margin: 0;
            flex-shrink: 0;
        }

        .timeline-slider {
            flex: 1;
            min-width: 200px;
            height: 6px;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
            background: #444;
            border-radius: 3px;
            outline: none;
        }

        .timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #ff6b6b;
            cursor: pointer;
            border-radius: 50%;
        }

        .timeline-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #ff6b6b;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        #timeDisplay {
            font-size: 12px;
            color: #aaa;
            min-width: 100px;
            text-align: right;
        }

        .audio-controls {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 13px;
        }

        .audio-controls input[type="file"] {
            flex: 1;
            padding: 8px;
            background: #2d2d2d;
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
        }

        .metronome-info {
            font-size: 11px;
            color: #888;
            margin-top: 5px;
        }

        #editorCanvas {
            flex: 1;
            background: #000;
            border: 2px solid #444;
            border-radius: 4px;
            cursor: crosshair;
            display: block;
            width: 100%;
        }

        .sidebar::-webkit-scrollbar {
            width: 8px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: #2d2d2d;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }

        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #777;
        }

        .keyboard-hint {
            font-size: 11px;
            color: #666;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #444;
        }
    </style>
</head>
<body>
<div class="container">
    <aside class="sidebar">
        <h1>Chart Editor</h1>

        <section class="section">
            <h2>Êõ≤ÊÉÖÂ†±</h2>
            <div class="form-group">
                <label for="songName">Êõ≤Âêç</label>
                <input type="text" id="songName" placeholder="TestSong" value="TestSong">
            </div>
            <div class="form-group">
                <label for="bpmInput">BPM</label>
                <input type="number" id="bpmInput" placeholder="150" value="150" min="1">
            </div>
        </section>

        <section class="section">
            <h2>„Éé„Éº„ÉÑÁ∑®ÈõÜ„É¢„Éº„Éâ</h2>
            <div class="tabs">
                <button class="tab-btn active" data-tab="player">„Éó„É¨„Ç§„É§„Éº</button>
                <button class="tab-btn" data-tab="opponent">Áõ∏Êâã</button>
            </div>
        </section>

        <div id="player-tab" class="tab-content active">
            <section class="section">
                <h2>„Éó„É¨„Ç§„É§„Éº„Éé„Éº„ÉÑ</h2>
                <div class="form-group">
                    <label for="laneSelect">„É¨„Éº„É≥ÈÅ∏Êäû</label>
                    <select id="laneSelect">
                        <option value="0">„É¨„Éº„É≥ 0 (Ëµ§)</option>
                        <option value="1">„É¨„Éº„É≥ 1 (Èùí)</option>
                        <option value="2">„É¨„Éº„É≥ 2 (Á∑ë)</option>
                        <option value="3">„É¨„Éº„É≥ 3 (ÈªÑ)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="holdLength">Èï∑Êäº„ÅóÈï∑„Åï (ms)</label>
                    <input type="number" id="holdLength" placeholder="0" value="0" min="0">
                </div>
                <button class="btn" id="addNoteBtn">„Éé„Éº„ÉÑ„ÇíËøΩÂä†</button>
                <button class="btn btn-danger" id="deleteNoteBtn">ÈÅ∏Êäû„Éé„Éº„ÉÑÂâäÈô§</button>
                <button class="btn btn-secondary" id="clearAllBtn">ÂÖ®ÂâäÈô§</button>
                <div class="stat-item" style="margin-top: 10px;">
                    <span>„Éé„Éº„ÉÑÊï∞:</span>
                    <strong id="noteCount">0</strong>
                </div>
                <div class="stat-item">
                    <span>ÈÅ∏Êäû:</span>
                    <strong id="selectedNoteDisplay">„Å™„Åó</strong>
                </div>
            </section>
        </div>

        <div id="opponent-tab" class="tab-content">
            <section class="section">
                <h2>Áõ∏Êâã„Éé„Éº„ÉÑ</h2>
                <div class="form-group">
                    <label for="opponentLaneSelect">„É¨„Éº„É≥ÈÅ∏Êäû</label>
                    <select id="opponentLaneSelect">
                        <option value="0">„É¨„Éº„É≥ 0 (Ëµ§)</option>
                        <option value="1">„É¨„Éº„É≥ 1 (Èùí)</option>
                        <option value="2">„É¨„Éº„É≥ 2 (Á∑ë)</option>
                        <option value="3">„É¨„Éº„É≥ 3 (ÈªÑ)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="opponentHoldLength">Èï∑Êäº„ÅóÈï∑„Åï (ms)</label>
                    <input type="number" id="opponentHoldLength" placeholder="0" value="0" min="0">
                </div>
                <button class="btn" id="addOpponentNoteBtn">„Éé„Éº„ÉÑ„ÇíËøΩÂä†</button>
                <button class="btn btn-danger" id="deleteOpponentNoteBtn">ÈÅ∏Êäû„Éé„Éº„ÉÑÂâäÈô§</button>
                <button class="btn btn-secondary" id="clearOpponentBtn">ÂÖ®ÂâäÈô§</button>
                <div class="stat-item" style="margin-top: 10px;">
                    <span>„Éé„Éº„ÉÑÊï∞:</span>
                    <strong id="opponentNoteCount">0</strong>
                </div>
                <div class="stat-item">
                    <span>ÈÅ∏Êäû:</span>
                    <strong id="selectedOpponentNoteDisplay">„Å™„Åó</strong>
                </div>
            </section>
        </div>

        <section class="section">
            <h2>„Éï„Ç°„Ç§„É´Êìç‰Ωú</h2>
            <button class="btn" id="downloadBtn">JSON „ÉÄ„Ç¶„É≥„É≠„Éº„Éâ</button>
            <button class="btn" id="uploadBtn">JSON Ë™≠Ëæº</button>
            <input type="file" id="fileInput" accept=".json" style="display:none">
        </section>

        <section class="section">
            <h2>ÂÜçÁîüÊÉÖÂ†±</h2>
            <div class="stat-item">
                <span>ÁèæÂú®ÊôÇÂàª:</span>
                <strong id="currentTimeDisplay">0.00s</strong>
            </div>
            <div class="stat-item">
                <span>ÂÜçÁîüÁä∂ÊÖã:</span>
                <strong id="playStatus">ÂÅúÊ≠¢‰∏≠</strong>
            </div>
        </section>

        <div class="keyboard-hint">
            <strong>„Ç≠„Éº„Éú„Éº„ÉâÊìç‰Ωú:</strong><br>
            ‚Üë/W: Ââç„Å∏„Çπ„ÇØ„É≠„Éº„É´<br>
            ‚Üì/S: Âæå„Çç„Å∏„Çπ„ÇØ„É≠„Éº„É´<br>
            A: BPM-1<br>
            D: BPM+1
        </div>
    </aside>

    <main class="main-content">
        <div class="editor-controls">
            <button class="btn btn-small" id="playBtn">‚ñ∂ ÂÜçÁîü</button>
            <button class="btn btn-small" id="pauseBtn">‚è∏ ‰∏ÄÊôÇÂÅúÊ≠¢</button>
            <button class="btn btn-small" id="stopBtn">‚èπ ÂÅúÊ≠¢</button>
            <input type="range" id="timelineSlider" min="0" max="100" value="0" class="timeline-slider">
            <span id="timeDisplay">0:00 / 0:00</span>
        </div>

        <div class="audio-controls">
            <label for="audioInput">„Ç™„Éº„Éá„Ç£„Ç™„Éï„Ç°„Ç§„É´:</label>
            <input type="file" id="audioInput" accept="audio/*">
            <div class="metronome-info">üí° Êú™ÈÅ∏ÊäûÊôÇ„ÅØ„É°„Éà„É≠„Éé„Éº„É†Èü≥„ÅßÂÜçÁîü</div>
        </div>

        <canvas id="editorCanvas"></canvas>
        <audio id="audioPlayer"></audio>
    </main>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const state = {
        songName: 'TestSong',
        bpm: 150,
        notes: [],
        opponentNotes: [],
        selectedNoteIndex: null,
        selectedOpponentNoteIndex: null,
        audioFile: null,
        currentTime: 0,
        duration: 0,
        isPlaying: false,
        pixelsPerMs: 0.15,
        currentMode: 'player',
        scrollOffset: 0,
        metronomePlaying: false,
        lastBeatTime: 0
    };

    const songNameInput = document.getElementById('songName');
    const bpmInput = document.getElementById('bpmInput');
    const laneSelect = document.getElementById('laneSelect');
    const holdLengthInput = document.getElementById('holdLength');
    const opponentLaneSelect = document.getElementById('opponentLaneSelect');
    const opponentHoldLengthInput = document.getElementById('opponentHoldLength');
    
    const addNoteBtn = document.getElementById('addNoteBtn');
    const deleteNoteBtn = document.getElementById('deleteNoteBtn');
    const clearAllBtn = document.getElementById('clearAllBtn');
    const addOpponentNoteBtn = document.getElementById('addOpponentNoteBtn');
    const deleteOpponentNoteBtn = document.getElementById('deleteOpponentNoteBtn');
    const clearOpponentBtn = document.getElementById('clearOpponentBtn');
    
    const downloadBtn = document.getElementById('downloadBtn');
    const uploadBtn = document.getElementById('uploadBtn');
    const fileInput = document.getElementById('fileInput');
    const audioInput = document.getElementById('audioInput');

    const audioPlayer = document.getElementById('audioPlayer');
    const playBtn = document.getElementById('playBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const stopBtn = document.getElementById('stopBtn');
    const canvas = document.getElementById('editorCanvas');
    const ctx = canvas.getContext('2d');
    const timelineSlider = document.getElementById('timelineSlider');
    
    const noteCountDisplay = document.getElementById('noteCount');
    const opponentNoteCountDisplay = document.getElementById('opponentNoteCount');
    const selectedNoteDisplay = document.getElementById('selectedNoteDisplay');
    const selectedOpponentNoteDisplay = document.getElementById('selectedOpponentNoteDisplay');
    const currentTimeDisplay = document.getElementById('currentTimeDisplay');
    const timeDisplay = document.getElementById('timeDisplay');
    const playStatus = document.getElementById('playStatus');

    const tabButtons = document.querySelectorAll('.tab-btn');
    const tabContents = document.querySelectorAll('.tab-content');

    const laneColors = ['#ff6b6b', '#4a90e2', '#51cf66', '#ffd93d'];
    const opponentLaneColors = ['#ff6b6b', '#4a90e2', '#51cf66', '#ffd93d'].map(c => c + '80');
    const laneName = ['Ëµ§', 'Èùí', 'Á∑ë', 'ÈªÑ'];

    const audioContext = new (window.AudioContext || window.webkitAudioContext)();

    function playMetronomeClick() {
        try {
            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            osc.connect(gain);
            gain.connect(audioContext.destination);
            
            osc.frequency.value = 800;
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            
            osc.start(now);
            osc.stop(now + 0.1);
        } catch (e) {
            console.log('„É°„Éà„É≠„Éé„Éº„É†Èü≥Â£∞ÁîüÊàê„Ç®„É©„Éº:', e);
        }
    }

    function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
    }

    function addNoteAtCurrentTime() {
        const lane = parseInt(laneSelect.value);
        const holdLength = parseInt(holdLengthInput.value) || 0;
        const note = {
            time: state.currentTime,
            lane: lane,
            hold: holdLength
        };
        state.notes.push(note);
        state.notes.sort((a, b) => a.time - b.time);
        updateDisplay();
    }

    function deleteSelectedNote() {
        if (state.selectedNoteIndex !== null) {
            state.notes.splice(state.selectedNoteIndex, 1);
            state.selectedNoteIndex = null;
            updateDisplay();
        }
    }

    function addOpponentNoteAtCurrentTime() {
        const lane = parseInt(opponentLaneSelect.value);
        const holdLength = parseInt(opponentHoldLengthInput.value) || 0;
        const note = {
            time: state.currentTime,
            lane: lane,
            hold: holdLength
        };
        state.opponentNotes.push(note);
        state.opponentNotes.sort((a, b) => a.time - b.time);
        updateDisplay();
    }

    function deleteSelectedOpponentNote() {
        if (state.selectedOpponentNoteIndex !== null) {
            state.opponentNotes.splice(state.selectedOpponentNoteIndex, 1);
            state.selectedOpponentNoteIndex = null;
            updateDisplay();
        }
    }

    function canvasClickHandler(e) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const laneWidth = canvas.width / 4;
        const lane = Math.floor(x / laneWidth);
        const time = state.currentTime + state.scrollOffset + (canvas.height / 2 - y) / state.pixelsPerMs;

        if (state.currentMode === 'player') {
            const clickedIndex = findNoteAtPosition(x, y, false);
            if (clickedIndex !== null) {
                state.selectedNoteIndex = clickedIndex;
            } else {
                const note = {
                    time: Math.max(0, time),
                    lane: Math.min(3, Math.max(0, lane)),
                    hold: 0
                };
                state.notes.push(note);
                state.notes.sort((a, b) => a.time - b.time);
            }
        } else {
            const clickedIndex = findNoteAtPosition(x, y, true);
            if (clickedIndex !== null) {
                state.selectedOpponentNoteIndex = clickedIndex;
            } else {
                const note = {
                    time: Math.max(0, time),
                    lane: Math.min(3, Math.max(0, lane)),
                    hold: 0
                };
                state.opponentNotes.push(note);
                state.opponentNotes.sort((a, b) => a.time - b.time);
            }
        }

        updateDisplay();
    }

    function findNoteAtPosition(x, y, isOpponent) {
        const laneWidth = canvas.width / 4;
        const clickTolerance = 12;
        const notes = isOpponent ? state.opponentNotes : state.notes;

        for (let i = 0; i < notes.length; i++) {
            const note = notes[i];
            const noteX = note.lane * laneWidth + laneWidth / 2;
            const noteY = canvas.height / 2 - (note.time - state.currentTime - state.scrollOffset) * state.pixelsPerMs;

            const dx = x - noteX;
            const dy = y - noteY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < clickTolerance + 10) {
                return i;
            }
        }
        return null;
    }

    function draw() {
        const laneWidth = canvas.width / 4;

        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        for (let i = 1; i < 4; i++) {
            ctx.beginPath();
            ctx.moveTo(i * laneWidth, 0);
            ctx.lineTo(i * laneWidth, canvas.height);
            ctx.stroke();
        }

        ctx.strokeStyle = '#444';
        ctx.fillStyle = '#666';
        ctx.font = '10px monospace';
        const beatMs = 60000 / state.bpm;
        const visibleMs = canvas.height / state.pixelsPerMs;
        const startTime = state.currentTime + state.scrollOffset - visibleMs / 2;
        const endTime = state.currentTime + state.scrollOffset + visibleMs / 2;

        const firstBeat = Math.floor(startTime / beatMs);
        const lastBeat = Math.ceil(endTime / beatMs);

        for (let beat = firstBeat; beat <= lastBeat; beat++) {
            const beatTime = beat * beatMs;
            const beatY = canvas.height / 2 - (beatTime - state.currentTime - state.scrollOffset) * state.pixelsPerMs;

            if (beatY >= 0 && beatY <= canvas.height) {
                ctx.beginPath();
                ctx.moveTo(0, beatY);
                ctx.lineTo(canvas.width, beatY);
                ctx.stroke();

                if (beat % 4 === 0) {
                    const seconds = beatTime / 1000;
                    ctx.fillText(seconds.toFixed(1) + 's', 5, beatY - 5);
                }
            }
        }

        drawNotes();

        ctx.strokeStyle = '#ff6b6b';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(0, canvas.height / 2);
        ctx.lineTo(canvas.width, canvas.height / 2);
        ctx.stroke();
    }

    function drawNotes() {
        const laneWidth = canvas.width / 4;

        for (let i = 0; i < state.notes.length; i++) {
            const note = state.notes[i];
            const isSelected = i === state.selectedNoteIndex;

            const noteX = note.lane * laneWidth;
            const noteY = canvas.height / 2 - (note.time - state.currentTime - state.scrollOffset) * state.pixelsPerMs;

            if (noteY < -50 || noteY > canvas.height + 50) continue;

            ctx.fillStyle = isSelected ? '#ffffff' : laneColors[note.lane];
            ctx.globalAlpha = isSelected ? 1 : 0.9;
            ctx.fillRect(noteX + 5, noteY - 10, laneWidth - 10, 20);

            if (note.hold > 0) {
                const holdEndY = canvas.height / 2 - (note.time + note.hold - state.currentTime - state.scrollOffset) * state.pixelsPerMs;
                ctx.fillRect(noteX + laneWidth / 2 - 5, noteY, 10, holdEndY - noteY);
            }

            if (isSelected) {
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 2;
                ctx.strokeRect(noteX + 5, noteY - 10, laneWidth - 10, 20);
            }

            ctx.globalAlpha = 1;
        }

        for (let i = 0; i < state.opponentNotes.length; i++) {
            const note = state.opponentNotes[i];
            const isSelected = i === state.selectedOpponentNoteIndex;

            const noteX = note.lane * laneWidth;
            const noteY = canvas.height / 2 - (note.time - state.currentTime - state.scrollOffset) * state.pixelsPerMs;

            if (noteY < -50 || noteY > canvas.height + 50) continue;

            ctx.fillStyle = isSelected ? '#ffffff' : opponentLaneColors[note.lane];
            ctx.globalAlpha = isSelected ? 1 : 0.6;
            ctx.fillRect(noteX + 8, noteY - 8, laneWidth - 16, 16);

            if (note.hold > 0) {
                const holdEndY = canvas.height / 2 - (note.time + note.hold - state.currentTime - state.scrollOffset) * state.pixelsPerMs;
                ctx.fillRect(noteX + laneWidth / 2 - 2, noteY, 4, holdEndY - noteY);
            }

            if (isSelected) {
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 2;
                ctx.strokeRect(noteX + 8, noteY - 8, laneWidth - 16, 16);
            }

            ctx.globalAlpha = 1;
        }
    }

    function downloadJSON() {
        const beatMs = 60000 / state.bpm;
        const sectionDuration = beatMs * 4;

        const playerSections = convertNotesToSections(state.notes, sectionDuration);
        const opponentSections = convertNotesToSections(state.opponentNotes, sectionDuration);

        const jsonData = {
            song: {
                song: state.songName,
                bpm: state.bpm,
                notes: playerSections,
                opponentNotes: opponentSections
            }
        };

        const jsonStr = JSON.stringify(jsonData, null, 2);
        const blob = new Blob([jsonStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${state.songName}.json`;
        a.click();
        URL.revokeObjectURL(url);
    }

    function convertNotesToSections(notes, sectionDuration) {
        if (notes.length === 0) {
            return [{ sectionNotes: [], mustHitSection: true }];
        }

        const sections = [];
        let currentSection = { sectionNotes: [], mustHitSection: true };
        let currentSectionStartTime = 0;

        for (const note of notes) {
            const sectionIndex = Math.floor(note.time / sectionDuration);
            const sectionStartTime = sectionIndex * sectionDuration;

            while (currentSectionStartTime < sectionStartTime) {
                sections.push(currentSection);
                currentSectionStartTime += sectionDuration;
                currentSection = { sectionNotes: [], mustHitSection: true };
            }

            currentSection.sectionNotes.push([
                note.time - currentSectionStartTime,
                note.lane,
                note.hold
            ]);
        }

        sections.push(currentSection);
        return sections;
    }

    function uploadJSON(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const json = JSON.parse(event.target.result);
                state.songName = json.song.song || 'TestSong';
                state.bpm = json.song.bpm || 150;

                const beatMs = 60000 / state.bpm;
                const sectionDuration = beatMs * 4;

                state.notes = [];
                state.opponentNotes = [];

                if (json.song.notes) {
                    for (let sectionIndex = 0; sectionIndex < json.song.notes.length; sectionIndex++) {
                        const section = json.song.notes[sectionIndex];
                        const sectionStartTime = sectionIndex * sectionDuration;

                        for (const noteData of section.sectionNotes) {
                            const note = {
                                time: sectionStartTime + noteData[0],
                                lane: noteData[1],
                                hold: noteData[2] || 0
                            };
                            state.notes.push(note);
                        }
                    }
                }

                if (json.song.opponentNotes) {
                    for (let sectionIndex = 0; sectionIndex < json.song.opponentNotes.length; sectionIndex++) {
                        const section = json.song.opponentNotes[sectionIndex];
                        const sectionStartTime = sectionIndex * sectionDuration;

                        for (const noteData of section.sectionNotes) {
                            const note = {
                                time: sectionStartTime + noteData[0],
                                lane: noteData[1],
                                hold: noteData[2] || 0
                            };
                            state.opponentNotes.push(note);
                        }
                    }
                }

                songNameInput.value = state.songName;
                bpmInput.value = state.bpm;
                state.selectedNoteIndex = null;
                state.selectedOpponentNoteIndex = null;
                updateDisplay();
            } catch (error) {
                alert('JSONË™≠Ëæº„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + error.message);
            }
        };
        reader.readAsText(file);
    }

    function updateDisplay() {
        noteCountDisplay.textContent = state.notes.length;
        opponentNoteCountDisplay.textContent = state.opponentNotes.length;

        if (state.currentMode === 'player') {
            if (state.selectedNoteIndex !== null) {
                const note = state.notes[state.selectedNoteIndex];
                selectedNoteDisplay.textContent = `${laneName[note.lane]} @ ${note.time.toFixed(0)}ms`;
            } else {
                selectedNoteDisplay.textContent = '„Å™„Åó';
            }
        } else {
            if (state.selectedOpponentNoteIndex !== null) {
                const note = state.opponentNotes[state.selectedOpponentNoteIndex];
                selectedOpponentNoteDisplay.textContent = `${laneName[note.lane]} @ ${note.time.toFixed(0)}ms`;
            } else {
                selectedOpponentNoteDisplay.textContent = '„Å™„Åó';
            }
        }

        currentTimeDisplay.textContent = (state.currentTime / 1000).toFixed(2) + 's';

        const maxDuration = Math.max(state.duration, 10000);
        if (maxDuration > 0) {
            const ratio = (state.currentTime / maxDuration) * 100;
            timelineSlider.value = ratio;
        }

        const minutes = Math.floor(state.currentTime / 60000);
        const seconds = Math.floor((state.currentTime % 60000) / 1000);
        const durationMinutes = Math.floor(maxDuration / 60000);
        const durationSeconds = Math.floor((maxDuration % 60000) / 1000);
        timeDisplay.textContent = `${minutes}:${String(seconds).padStart(2, '0')} / ${durationMinutes}:${String(durationSeconds).padStart(2, '0')}`;

        playStatus.textContent = state.isPlaying ? 'ÂÜçÁîü‰∏≠' : 'ÂÅúÊ≠¢‰∏≠';

        if (state.metronomePlaying) {
            const beatMs = 60000 / state.bpm;
            if (state.currentTime - state.lastBeatTime >= beatMs) {
                playMetronomeClick();
                state.lastBeatTime = state.currentTime;
            }
        }

        draw();
    }

    function startPlayback() {
        if (audioPlayer.src) {
            audioPlayer.play();
        }
        state.isPlaying = true;
        state.metronomePlaying = true;
        updateDisplay();
    }

    function pausePlayback() {
        if (audioPlayer.src) {
            audioPlayer.pause();
        }
        state.isPlaying = false;
        state.metronomePlaying = false;
        updateDisplay();
    }

    function stopPlayback() {
        if (audioPlayer.src) {
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
        }
        state.currentTime = 0;
        state.isPlaying = false;
        state.metronomePlaying = false;
        state.scrollOffset = 0;
        updateDisplay();
    }

    function handleKeyboard(e) {
        const step = 500;
        const bpmStep = 1;

        switch(e.key.toLowerCase()) {
            case 'arrowup':
            case 'w':
                state.scrollOffset = Math.max(0, state.scrollOffset - step);
                e.preventDefault();
                updateDisplay();
                break;
            case 'arrowdown':
            case 's':
                state.scrollOffset += step;
                e.preventDefault();
                updateDisplay();
                break;
            case 'a':
                state.bpm = Math.max(1, state.bpm - bpmStep);
                bpmInput.value = state.bpm;
                e.preventDefault();
                updateDisplay();
                break;
            case 'd':
                state.bpm += bpmStep;
                bpmInput.value = state.bpm;
                e.preventDefault();
                updateDisplay();
                break;
        }
    }

    function startAnimationLoop() {
        if (state.isPlaying && !audioPlayer.src) {
            const frameTime = 16.67;
            state.currentTime += frameTime;
            
            const maxDuration = Math.max(state.duration, 30000);
            if (state.currentTime >= maxDuration) {
                stopPlayback();
            }
        }

        updateDisplay();
        requestAnimationFrame(startAnimationLoop);
    }

    // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„ÉºÁôªÈå≤
    songNameInput.addEventListener('change', (e) => {
        state.songName = e.target.value;
    });

    bpmInput.addEventListener('change', (e) => {
        state.bpm = Math.max(1, parseInt(e.target.value) || 150);
        bpmInput.value = state.bpm;
    });

    tabButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
            const tabName = e.target.dataset.tab;
            tabButtons.forEach(b => b.classList.remove('active'));
            tabContents.forEach(c => c.classList.remove('active'));
            e.target.classList.add('active');
            document.getElementById(`${tabName}-tab`).classList.add('active');
            state.currentMode = tabName;
        });
    });

    audioInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const url = URL.createObjectURL(file);
            audioPlayer.src = url;
            state.audioFile = file;
            audioPlayer.addEventListener('loadedmetadata', () => {
                state.duration = audioPlayer.duration * 1000;
                updateDisplay();
            }, { once: true });
        }
    });

    addNoteBtn.addEventListener('click', addNoteAtCurrentTime);
    deleteNoteBtn.addEventListener('click', deleteSelectedNote);
    clearAllBtn.addEventListener('click', () => {
        if (confirm('ÂÖ®„Å¶„ÅÆ„Éó„É¨„Ç§„É§„Éº„Éé„Éº„ÉÑ„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) {
            state.notes = [];
            state.selectedNoteIndex = null;
            updateDisplay();
        }
    });

    addOpponentNoteBtn.addEventListener('click', addOpponentNoteAtCurrentTime);
    deleteOpponentNoteBtn.addEventListener('click', deleteSelectedOpponentNote);
    clearOpponentBtn.addEventListener('click', () => {
        if (confirm('ÂÖ®„Å¶„ÅÆÁõ∏Êâã„Éé„Éº„ÉÑ„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) {
            state.opponentNotes = [];
            state.selectedOpponentNoteIndex = null;
            updateDisplay();
        }
    });

    playBtn.addEventListener('click', startPlayback);
    pauseBtn.addEventListener('click', pausePlayback);
    stopBtn.addEventListener('click', stopPlayback);

    timelineSlider.addEventListener('input', (e) => {
        const ratio = parseFloat(e.target.value) / 100;
        state.currentTime = ratio * Math.max(state.duration, 10000);
        if (audioPlayer.src) {
            audioPlayer.currentTime = state.currentTime / 1000;
        }
        updateDisplay();
    });

    audioPlayer.addEventListener('timeupdate', () => {
        state.currentTime = audioPlayer.currentTime * 1000;
        updateDisplay();
    });

    audioPlayer.addEventListener('ended', stopPlayback);

    downloadBtn.addEventListener('click', downloadJSON);
    uploadBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', uploadJSON);

    canvas.addEventListener('click', canvasClickHandler);

    document.addEventListener('keydown', handleKeyboard);

    window.addEventListener('resize', () => {
        resizeCanvas();
        draw();
    });

    // ÂàùÊúüÂåñ
    resizeCanvas();
    state.songName = songNameInput.value;
    state.bpm = parseInt(bpmInput.value) || 150;
    updateDisplay();
    startAnimationLoop();
});
</script>
</body>
</html>